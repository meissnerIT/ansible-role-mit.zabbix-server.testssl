#!/usr/bin/env python3
#
# Distributed via ansible - mit.zabbix-server.testssl
#
# #17257: Checks given host via zabbix-mit-testssl-helper (which calls 
# testssl.sh) and reports back via zabbix_sender.
# 
# Idempotent - can be called as often as you wish.
#
# zabbix-mit-testssl-caller -> zabbix-mit-testssl -> zabbix-mit-testssl-helper
#
# Example:
# zabbix-mit-testssl http www.meissner.it
# zabbix-mit-testssl smtp mail.meissner.it
# zabbix-mit-testssl imap mail.meissner.it
#
# v2021-11-08-1

# https://www.askpython.com/python/python-command-line-arguments
import argparse
import configparser
import os
import subprocess
import sys
import logging
# https://github.com/lukecyca/pyzabbix
from pyzabbix import ZabbixAPI

formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
shStdout = logging.StreamHandler(sys.stdout)
shStdout.setFormatter(formatter)
shStderr = logging.StreamHandler(sys.stderr)
shStderr.setFormatter(formatter)
shStderr.setLevel(logging.ERROR)

log = logging.getLogger(os.path.basename(__file__))
log.addHandler(shStdout)
log.addHandler(shStderr)
log.setLevel(logging.INFO)

parser = argparse.ArgumentParser()
parser.add_argument("protocol")
parser.add_argument("host")
args = parser.parse_args()

configParser = configparser.RawConfigParser()
configFilePath = r'/etc/zabbix/zabbix_agentd-mit-testssl.sh.conf'
configParser.read(configFilePath)
zabbix_api_user = configParser.get('DEFAULT', 'zabbix-api.user')
zabbix_api_password = configParser.get('DEFAULT', 'zabbix-api.password')
zabbix_api_url = configParser.get('DEFAULT', 'zabbix-api.url')
zabbix_host = configParser.get('DEFAULT', 'zabbix.host')

# detect_version=False - https://github.com/lukecyca/pyzabbix/issues/157
zapi = ZabbixAPI(zabbix_api_url, detect_version=False)
if configParser.has_option('DEFAULT', 'zabbix-api.verify'):
    # https://requests.readthedocs.io/en/master/user/advanced/#ssl-cert-verification
    zapi.session.verify = configParser.get('DEFAULT', 'zabbix-api.verify')

zapi.login(zabbix_api_user, zabbix_api_password)
log.debug("Connected to Zabbix API Version %s" % zapi.api_version())

hosts = zapi.host.get(filter={"host": args.host})
if not hosts:
    log.error("Could not find host '%s'" % args.host)
    exit(1)

host = hosts[0]
log.debug("Found %s (id=%s)" % (host['host'], host['hostid']))

if args.protocol == "http":
    macroNamePort = "{$TLS_PORT}"
    macroNameHost = "{$TLS_HOST}"
    defaultPort = 443
else:
    macroNamePort = "{$TLS_" + args.protocol.upper() + "_PORT}"
    macroNameHost = "{$TLS_" + args.protocol.upper() + "_HOST}"
    if args.protocol == "smtp":
        defaultPort = 25
    elif args.protocol == "imap":
        defaultPort = 143

usermacroTlsHost = zapi.usermacro.get(hostids=host['hostid'], filter={ "macro": macroNameHost })
if usermacroTlsHost:
    tlsHost = usermacroTlsHost[0]["value"]
    log.debug("Using host %s based on macro %s" % (tlsHost, macroNameHost))
else:
    hostinterface = zapi.hostinterface.get(hostids=host['hostid'])
    log.debug(hostinterface)
    if hostinterface[0]['useip']=='1':
        tlsHost = hostinterface[0]['ip']
    else:
        tlsHost = hostinterface[0]['dns']
    log.debug("Using host %s based on host interface" % tlsHost)

usermacroTlsPort = zapi.usermacro.get(hostids=host['hostid'], filter={ "macro": macroNamePort })
if usermacroTlsPort:
    tlsPort = usermacroTlsPort[0]["value"]
else:
    tlsPort = defaultPort
log.debug("Using port %s based on macro %s" % (tlsPort, macroNamePort))

url = "%s:%s" % (tlsHost, tlsPort)

testsslCmd = ["/usr/local/bin/zabbix-mit-testssl-helper", args.protocol, url]
#testsslCmd = ["echo"]
log.info("Checking %s with protocol %s via %s" % (host['host'], args.protocol, url))
testsslCmdCompleted = subprocess.run(testsslCmd, stdout = subprocess.PIPE, stderr=subprocess.PIPE)
if testsslCmdCompleted.returncode == 0 and len(testsslCmdCompleted.stderr) == 0:
    testsslOutput = testsslCmdCompleted.stdout.decode('utf-8').strip()
    log.debug("Got '%s' from %s" % (testsslOutput, testsslCmd))
    zabbixSenderCmd = [r'zabbix_sender', '-z', zabbix_host, '-s', host['host'], '-k', 'mit-testssl-' + args.protocol, '-o', '%s' % (testsslOutput)]
    log.debug("Executing %s" % zabbixSenderCmd)
    try:
        zabbixSenderOutput = subprocess.check_output(zabbixSenderCmd).strip()
        log.debug("Called %s, got %s" % (zabbixSenderCmd, zabbixSenderOutput))
        log.info("Transmitted result '%s' for %s to zabbix server" % (testsslOutput, host['host']))
    except:
        log.error("Got error while executing %s" % (zabbixSenderCmd))
        log.error(zabbixSenderOutput)
else:
    log.warning("Got returncode %s and stderr='%s' while checking %s" % (testsslCmdCompleted.returncode, testsslCmdCompleted.stderr.decode('utf-8'), host['host']))
    # Do nothing, Zabbix has a trigger for nodata(2d)
log.info("READY.")

